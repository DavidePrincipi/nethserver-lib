#!/usr/bin/python

#
# Copyright (C) 2013 Nethesis S.r.l.
# http://www.nethesis.it - support@nethesis.it
# 
# This script is part of NethServer.
# 
# NethServer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License,
# or any later version.
# 
# NethServer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with NethServer.  If not, see <http://www.gnu.org/licenses/>.
#

from __future__ import print_function

import nethserver.ptrack
import logging
import logging.handlers
import os
import sys
import signal
import json
import io
import hashlib

exit_code = 0

def warning(*objs):
    print(*objs, file=sys.stderr)

def daemonize():
    os.closerange(0,2)
    if os.fork():
        os._exit(0)            
    os.setsid()

def main(args):

    logger = logging.getLogger('ptrack')
    logger.addHandler(logging.handlers.SysLogHandler(address='/dev/log'))

    try:
        uidata = json.load(sys.stdin)
    except Exception as e:
        logger.exception("%s" % e)
        uidata = False

    if("PTRACK_DEBUG" in os.environ):
        logger.setLevel(logging.DEBUG)
    elif("debug" in uidata and uidata["debug"]):
        logger.setLevel(logging.DEBUG)

    if("PTRACK_SOCKETPATH" in os.environ):
        socket_path = os.environ["PTRACK_SOCKETPATH"]
    elif('socketPath' in uidata):
        socket_path = os.environ["PTRACK_SOCKETPATH"] \
                      = uidata['socketPath']
    else:
        socket_path = environ["PTRACK_SOCKETPATH"] \
                      = '/var/run/ptrack-%d.sock' % os.getpid()

    daemonize()

    state = nethserver.ptrack.ProgressState()
    server = nethserver.ptrack.TrackerServer(socket_path, state, True)

    def on_sigchld(signum, frame):
        global exit_code
        logger.debug("Received signal: %d" % signum)
        exit_code = os.WEXITSTATUS(os.wait()[1])
        logger.debug("Child exit code: %d" % exit_code)
        server.close()

    def dump():
        global exit_code
        oldmask = os.umask(0077)
        dumpfd = io.open('/var/spool/ptrack/%.16s.dump' % hashlib.md5(socket_path).hexdigest(), 'wb')
        dumpdata = state.query('tasks')
        dumpdata['exit_code'] = exit_code
        dumpdata['ui'] = uidata
        json.dump(dumpdata, dumpfd)
        dumpfd.close()
        os.umask(oldmask)

    signal.signal(signal.SIGCHLD, on_sigchld)

    if(len(args) == 0):
        warning("Listening on path %s\nType ^C to shutdown the server.\n" % socket_path)
        logger.debug("Listening on %s" % socket_path)
        try:
            server.loop()
        except KeyboardInterrupt:
            sys.stderr.write("\nInterrupted!\n")
            exit(0)        

    if(os.fork()):
        server.loop()
        dump()
        exit(exit_code)
    else:
        server.close()
        logger.debug("Spawning %s" % args)
        try:
            os.execv(args[0], args[0:])
        except Exception, e:
            logger.error("%s: %s" % (args[0], e))
            sys.exit(1)


if __name__ == "__main__":
    if len(sys.argv) > 0:
        main(sys.argv[1:])
    else:
        main([])
